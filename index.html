<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RolePlay Chat - AI è§’è‰²æ‰®æ¼”</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        body { font-family: 'Inter', 'PingFang SC', sans-serif; }
        .chat-container { height: calc(100vh - 180px); }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        .message-content p { margin-bottom: 0.5rem; }
        .message-content p:last-child { margin-bottom: 0; }
        .role-card.active { border-color: #3b82f6; background-color: #eff6ff; }
    </style>
</head>
<body class="bg-gray-50 text-gray-900">
    <div class="max-w-6xl mx-auto h-screen flex flex-col p-4">
        <!-- Header -->
        <header class="flex justify-between items-center mb-6 px-4">
            <h1 class="text-2xl font-bold text-blue-600"><i class="fas fa-mask mr-2"></i>RolePlay Chat</h1>
            <button id="settingsBtn" class="p-2 rounded-full hover:bg-gray-200 transition-colors">
                <i class="fas fa-cog text-xl text-gray-600"></i>
            </button>
        </header>

        <div class="flex flex-1 gap-6 overflow-hidden">
            <!-- Sidebar: Roles -->
            <aside class="w-1/4 flex flex-col gap-4 overflow-y-auto pr-2 scrollbar-hide">
                <div class="flex justify-between items-center">
                    <h2 class="font-semibold text-gray-700">è§’è‰²é€‰æ‹©</h2>
                    <button id="addRoleBtn" class="text-sm text-blue-600 hover:text-blue-800"><i class="fas fa-plus mr-1"></i>åˆ›å»º</button>
                </div>
                <div id="roleList" class="flex flex-col gap-3">
                    <!-- Roles will be injected here -->
                </div>
            </aside>

            <!-- Main Chat Area -->
            <main class="flex-1 flex flex-col bg-white rounded-2xl shadow-sm border border-gray-200 overflow-hidden">
                <!-- Chat Header -->
                <div id="activeRoleHeader" class="p-4 border-b border-gray-100 bg-gray-50 flex items-center gap-3">
                    <div class="w-10 h-10 rounded-full bg-blue-100 flex items-center justify-center text-blue-600 font-bold">
                        ?
                    </div>
                    <div class="flex-1">
                        <h3 class="font-bold text-gray-800" id="activeRoleName">è¯·é€‰æ‹©è§’è‰²</h3>
                        <p class="text-xs text-gray-500" id="activeRoleDesc">å¼€å§‹æ‚¨çš„å¯¹è¯</p>
                    </div>
                    <button id="playAllBtn" class="p-2 text-gray-400 hover:text-green-500 transition-colors hidden" title="è¿ç»­æ’­æ”¾æ‰€æœ‰å·²ç¼“å­˜éŸ³é¢‘">
                        <i class="fas fa-play-circle text-xl"></i>
                    </button>
                    <button id="clearChatBtn" class="p-2 text-gray-400 hover:text-red-500 transition-colors hidden" title="æ¸…ç©ºå½“å‰å¯¹è¯">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                </div>

                <!-- Messages -->
                <div id="chatMessages" class="flex-1 overflow-y-auto p-6 flex flex-col gap-4 chat-container">
                    <div class="text-center text-gray-400 mt-10">
                        <i class="fas fa-comments text-4xl mb-4"></i>
                        <p>é€‰æ‹©ä¸€ä¸ªè§’è‰²å¼€å§‹èŠå¤©å§</p>
                    </div>
                </div>

                <!-- Input Area -->
                <div class="p-4 border-t border-gray-100">
                    <form id="chatForm" class="flex gap-2 items-center">
                        <button type="button" id="voiceBtn" 
                                class="w-10 h-10 hidden items-center justify-center rounded-full bg-gray-100 hover:bg-blue-100 text-gray-500 hover:text-blue-600 transition-all disabled:opacity-50"
                                disabled title="è¯­éŸ³è¾“å…¥">
                            <i class="fas fa-microphone"></i>
                        </button>
                        <button type="button" id="autoReplyBtn" 
                                class="w-10 h-10 flex items-center justify-center rounded-full bg-gray-100 hover:bg-purple-100 text-gray-500 hover:text-purple-600 transition-all disabled:opacity-50"
                                disabled title="AI è‡ªåŠ¨å›å¤/ç»­å†™">
                            <i class="fas fa-robot"></i>
                        </button>
                        <input type="text" id="userInput" placeholder="è¾“å…¥æ¶ˆæ¯..." 
                               class="flex-1 px-4 py-2 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-100" 
                               disabled>
                        <button type="submit" id="sendBtn" 
                                class="bg-blue-600 text-white px-6 py-2 rounded-xl hover:bg-blue-700 transition-colors disabled:bg-gray-400" 
                                disabled>
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </form>
                    <div id="recordingStatus" class="hidden text-center mt-2">
                        <span class="inline-flex items-center px-3 py-1 rounded-full bg-red-100 text-red-600 text-xs font-medium animate-pulse">
                            <i class="fas fa-circle mr-2"></i> æ­£åœ¨å½•éŸ³... ç‚¹å‡»æŒ‰é’®åœæ­¢
                        </span>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-2xl p-6 w-full max-w-md shadow-xl max-h-[90vh] flex flex-col">
            <h2 class="text-xl font-bold mb-4 flex-shrink-0">API è®¾ç½®</h2>
            <div class="space-y-4 overflow-y-auto flex-1 pr-2">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">OpenRouter API Key</label>
                    <div class="flex gap-2">
                        <input type="password" id="apiKeyInput" placeholder="sk-or-v1-..." 
                               class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none">
                        <button id="verifyKey" class="px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm transition-colors">éªŒè¯å¹¶åŠ è½½</button>
                    </div>
                    <p class="text-xs text-gray-400 mt-1">Key å°†ä¿å­˜åœ¨æ‚¨çš„æµè§ˆå™¨æœ¬åœ°å­˜å‚¨ä¸­</p>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">é€‰æ‹©æ¨¡å‹</label>
                    <input type="text" id="modelSearch" placeholder="æœç´¢æ¨¡å‹ (å¦‚: gpt-4, claude)..." 
                           class="w-full px-4 py-2 border border-gray-300 rounded-t-lg focus:ring-2 focus:ring-blue-500 outline-none border-b-0 text-sm">
                    <select id="modelSelect" size="5" class="w-full px-2 py-1 border border-gray-300 rounded-b-lg focus:ring-2 focus:ring-blue-500 outline-none bg-white">
                        <option value="openai/gpt-3.5-turbo">Loading models...</option>
                    </select>
                    <button id="refreshModels" class="text-xs text-blue-600 mt-1 hover:underline">åˆ·æ–°æ¨¡å‹åˆ—è¡¨</button>
                </div>
                <hr class="border-gray-100">
                <div class="space-y-3 hidden">
                    <h3 class="text-sm font-bold text-gray-800">ç«å±±å¼•æ“è¯­éŸ³è¯†åˆ«è®¾ç½® (ASR)</h3>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Access Key (ASR)</label>
                        <input type="password" id="volcToken" placeholder="ç«å±±å¼•æ“ Access Key" 
                               class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">ASR Resource ID (èµ„æºæ ‡è¯†)</label>
                        <input type="text" id="volcCluster" placeholder="ä¾‹å¦‚: volc.bigasr.auc" 
                               class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none">
                    </div>
                </div>
                <hr class="border-gray-100 hidden">
                <div class="space-y-3">
                    <h3 class="text-sm font-bold text-gray-800">ç«å±±å¼•æ“è¯­éŸ³åˆæˆè®¾ç½® (TTS)</h3>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">AppID</label>
                        <input type="text" id="volcAppId" placeholder="ç«å±±å¼•æ“ AppID" 
                               class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Access Token (TTS)</label>
                        <input type="password" id="volcTtsToken" placeholder="ç«å±±å¼•æ“ Access Token" 
                               class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none">
                        <p class="text-[10px] text-gray-400 mt-1">æ³¨ï¼šTTS é€šå¸¸ä½¿ç”¨ Access Tokenï¼Œä¸ ASR çš„ Access Key ä¸åŒ</p>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">TTS Resource ID (èµ„æºæ ‡è¯†)</label>
                        <input type="text" id="volcTtsCluster" placeholder="ä¾‹å¦‚: volcano_tts æˆ– volc.tts.default" 
                               class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none">
                        <p class="text-[10px] text-gray-400 mt-1">æç¤ºï¼šè¯·ç¡®ä¿åœ¨ç«å±±å¼•æ“æ§åˆ¶å°å·²å¼€é€šå¯¹åº”æœåŠ¡å¹¶æˆæƒã€‚æ™®é€šéŸ³è‰²é€šå¸¸ç”¨ volcano_ttsï¼Œå¤§æ¨¡å‹éŸ³è‰²å¯èƒ½ç”¨ volc.tts.default</p>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">é»˜è®¤éŸ³è‰² (Voice Type)</label>
                        <input type="text" id="volcTtsVoice" placeholder="ä¾‹å¦‚: zh_female_vv_uranus_bigtts"
                               class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none">
                    </div>
                </div>
                <hr class="border-gray-100">
                <div class="space-y-3">
                    <h3 class="text-sm font-bold text-gray-800">Replicate æ–‡ç”Ÿå›¾è®¾ç½®</h3>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Replicate API Token</label>
                        <input type="password" id="replicateToken" placeholder="r8_..."
                               class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none">
                        <p class="text-[10px] text-gray-400 mt-1">ç”¨äºæ–‡ç”Ÿå›¾åŠŸèƒ½ã€‚åœ¨ <a href="https://replicate.com/account/api-tokens" target="_blank" class="text-blue-600 hover:underline">Replicate</a> è·å– API Token</p>
                    </div>
                </div>
                <div class="flex justify-end gap-3 mt-6">
                    <button id="closeSettings" class="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg">å…³é—­</button>
                    <button id="saveSettings" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">ä¿å­˜</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Role Modal -->
    <div id="roleModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-2xl p-6 w-full max-w-md shadow-xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-xl font-bold">åˆ›å»ºæ–°è§’è‰²</h2>
                <button id="closeRoleModal" class="text-gray-400 hover:text-gray-600">
                    <i class="fas fa-times"></i>
                </button>
            </div>

            <div class="overflow-y-auto flex-1 pr-2">
            <!-- AI Generation Section -->
            <div class="bg-blue-50 p-4 rounded-xl mb-6 border border-blue-100">
                <label class="block text-xs font-bold text-blue-600 uppercase tracking-wider mb-2">AI çµæ„Ÿä¸€é”®ç”Ÿæˆ</label>
                <div class="flex gap-2">
                    <input type="text" id="aiPromptInput" placeholder="è¾“å…¥ç®€å•æƒ³æ³•ï¼Œå¦‚ï¼šæ¯’èˆŒçš„çŒ«å’ªè€å¸ˆ" 
                           class="flex-1 px-4 py-2 border border-blue-200 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none text-sm">
                    <button id="aiGenerateBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-semibold hover:bg-blue-700 transition-all shadow-sm flex items-center gap-2 whitespace-nowrap">
                        <i class="fas fa-magic"></i> ç”Ÿæˆ
                    </button>
                </div>
                <p class="text-[10px] text-blue-400 mt-2">AI å°†è‡ªåŠ¨ä¸ºæ‚¨å¡«å†™ä¸‹æ–¹çš„è§’è‰²è¯¦æƒ…</p>
            </div>

            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">è§’è‰²åç§°</label>
                    <input type="text" id="newRoleName" placeholder="ä¾‹å¦‚ï¼šç¦å°”æ‘©æ–¯" 
                           class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">è§’è‰²æè¿° (ç®€çŸ­)</label>
                    <input type="text" id="newRoleDesc" placeholder="ä¾‹å¦‚ï¼šä¼Ÿå¤§çš„ä¾¦æ¢" 
                           class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">æç¤ºè¯ (System Prompt)</label>
                    <textarea id="newRolePrompt" rows="4" placeholder="æè¿°è§’è‰²çš„æ€§æ ¼ã€è¯´è¯æ–¹å¼å’ŒèƒŒæ™¯..." 
                              class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none"></textarea>
                </div>
                <div class="flex justify-end gap-3 mt-6">
                    <button id="cancelRoleModal" class="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg">å–æ¶ˆ</button>
                    <button id="saveRole" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-semibold">ä¿å­˜è§’è‰²</button>
                </div>
            </div>
            </div><!-- å…³é—­æ»šåŠ¨å®¹å™¨ -->
        </div>
    </div>

    <script>
        // State Management
        const state = {
            apiKey: localStorage.getItem('openrouter_api_key') || '',
            selectedModel: localStorage.getItem('selected_model') || 'x-ai/grok-4.1-fast',
            volcAppId: localStorage.getItem('volc_appid') || '',
            volcToken: localStorage.getItem('volc_token') || '',
            volcTtsToken: localStorage.getItem('volc_tts_token') || '',
            volcCluster: localStorage.getItem('volc_cluster') || 'volc.bigasr.auc',
            volcTtsCluster: localStorage.getItem('volc_tts_cluster') || 'volcano_tts',
            volcTtsVoice: localStorage.getItem('volc_tts_voice') || 'zh_female_vv_uranus_bigtts',
            replicateToken: localStorage.getItem('replicate_token') || '',
            allModels: [], // Store all fetched models for filtering
            roles: [
                { id: 'coach', name: 'ä¸“ä¸šå¥èº«æ•™ç»ƒ', desc: 'å……æ»¡åŠ¨åŠ›çš„ç§‘å­¦æŒ‡å¯¼è€…', prompt: 'You are a professional fitness coach with 10 years of experience. You are enthusiastic, positive, and speak with high motivation. You provide scientific training advice and nutritional guidance while constantly encouraging the user to persevere. Your responses should be professional, practical, and full of positive energy. Please respond in Chinese.', icon: 'ğŸ’ª' },
                { id: 'bartender', name: 'èµ›åšæœ‹å…‹è°ƒé…’å¸ˆ', desc: 'åä¹Œæ‰˜é‚¦ä¸–ç•Œçš„å€¾å¬è€…', prompt: 'You are a bartender under the neon lights of a cyberpunk metropolis in the year 2077. You have seen the highs and lows of human nature and speak with a hint of world-weariness and humor. You are an excellent listener, chatting with customers about life, technology, and this broken world while wiping glasses. Your responses should be emotional and carry a sci-fi atmosphere. Please respond in Chinese.', icon: 'ğŸ¸' },
                ...(JSON.parse(localStorage.getItem('custom_roles')) || [])
            ],
            currentRoleId: null,
            chatHistory: JSON.parse(localStorage.getItem('chat_history')) || {}, // roleId -> messages[]
            ttsCache: {}, // (text + voiceType) -> base64 audio
            currentAudio: null, // Track currently playing audio
            isPlayingAll: false, // Track if continuous playback is active
            playAllQueue: [] // Queue for continuous playback
        };

        // DOM Elements
        const elements = {
            settingsBtn: document.getElementById('settingsBtn'),
            settingsModal: document.getElementById('settingsModal'),
            closeSettings: document.getElementById('closeSettings'),
            saveSettings: document.getElementById('saveSettings'),
            apiKeyInput: document.getElementById('apiKeyInput'),
            verifyKey: document.getElementById('verifyKey'),
            modelSearch: document.getElementById('modelSearch'),
            modelSelect: document.getElementById('modelSelect'),
            refreshModels: document.getElementById('refreshModels'),
            
            roleList: document.getElementById('roleList'),
            addRoleBtn: document.getElementById('addRoleBtn'),
            roleModal: document.getElementById('roleModal'),
            closeRoleModal: document.getElementById('closeRoleModal'),
            cancelRoleModal: document.getElementById('cancelRoleModal'),
            saveRole: document.getElementById('saveRole'),
            newRoleName: document.getElementById('newRoleName'),
            newRoleDesc: document.getElementById('newRoleDesc'),
            newRolePrompt: document.getElementById('newRolePrompt'),
            aiPromptInput: document.getElementById('aiPromptInput'),
            aiGenerateBtn: document.getElementById('aiGenerateBtn'),

            chatMessages: document.getElementById('chatMessages'),
            chatForm: document.getElementById('chatForm'),
            userInput: document.getElementById('userInput'),
            sendBtn: document.getElementById('sendBtn'),
            voiceBtn: document.getElementById('voiceBtn'),
            autoReplyBtn: document.getElementById('autoReplyBtn'),
            recordingStatus: document.getElementById('recordingStatus'),
            volcAppId: document.getElementById('volcAppId'),
            volcToken: document.getElementById('volcToken'),
            volcTtsToken: document.getElementById('volcTtsToken'),
            volcCluster: document.getElementById('volcCluster'),
            volcTtsCluster: document.getElementById('volcTtsCluster'),
            volcTtsVoice: document.getElementById('volcTtsVoice'),
            replicateToken: document.getElementById('replicateToken'),
            activeRoleName: document.getElementById('activeRoleName'),
            activeRoleDesc: document.getElementById('activeRoleDesc'),
            activeRoleHeader: document.getElementById('activeRoleHeader'),
            clearChatBtn: document.getElementById('clearChatBtn'),
            playAllBtn: document.getElementById('playAllBtn')
        };

        // Initialize
        async function init() {
            // Configure marked to disable strikethrough which causes issues with tildes in roleplay
            marked.use({
                tokenizer: {
                    del(src) {
                        return false; // Disable strikethrough
                    }
                }
            });

            state.volcCluster = localStorage.getItem('volc_cluster') || 'volc.bigasr.auc';
            if (state.volcCluster === 'volc_auc_common') {
                state.volcCluster = 'volc.bigasr.auc';
                localStorage.setItem('volc_cluster', state.volcCluster);
            }
            
            renderRoles();
            elements.apiKeyInput.value = state.apiKey;
            elements.volcAppId.value = state.volcAppId;
            elements.volcToken.value = state.volcToken;
            elements.volcTtsToken.value = state.volcTtsToken;
            elements.volcCluster.value = state.volcCluster;
            elements.volcTtsCluster.value = state.volcTtsCluster;
            elements.volcTtsVoice.value = state.volcTtsVoice;
            elements.replicateToken.value = state.replicateToken;
            if (state.apiKey) {
                fetchModels();
            }
            setupEventListeners();
        }

        function setupEventListeners() {
            elements.settingsBtn.onclick = () => {
                elements.apiKeyInput.value = state.apiKey;
                elements.settingsModal.classList.remove('hidden');
            };
            elements.closeSettings.onclick = () => elements.settingsModal.classList.add('hidden');
            elements.saveSettings.onclick = () => {
                state.apiKey = elements.apiKeyInput.value;
                state.selectedModel = elements.modelSelect.value;
                state.volcAppId = elements.volcAppId.value;
                state.volcToken = elements.volcToken.value;
                state.volcTtsToken = elements.volcTtsToken.value;
                state.volcCluster = elements.volcCluster.value;
                state.volcTtsCluster = elements.volcTtsCluster.value;
                state.volcTtsVoice = elements.volcTtsVoice.value;
                state.replicateToken = elements.replicateToken.value;
                localStorage.setItem('openrouter_api_key', state.apiKey);
                localStorage.setItem('selected_model', state.selectedModel);
                localStorage.setItem('volc_appid', state.volcAppId);
                localStorage.setItem('volc_token', state.volcToken);
                localStorage.setItem('volc_tts_token', state.volcTtsToken);
                localStorage.setItem('volc_cluster', state.volcCluster);
                localStorage.setItem('volc_tts_cluster', state.volcTtsCluster);
                localStorage.setItem('volc_tts_voice', state.volcTtsVoice);
                localStorage.setItem('replicate_token', state.replicateToken);
                elements.settingsModal.classList.add('hidden');
                checkInputs();
            };

            elements.verifyKey.onclick = () => {
                state.apiKey = elements.apiKeyInput.value;
                fetchModels();
            };
            elements.refreshModels.onclick = fetchModels;

            elements.modelSearch.oninput = () => {
                const term = elements.modelSearch.value.toLowerCase();
                renderModelOptions(state.allModels.filter(m => 
                    m.id.toLowerCase().includes(term) || 
                    (m.name && m.name.toLowerCase().includes(term))
                ));
            };

            elements.addRoleBtn.onclick = () => elements.roleModal.classList.remove('hidden');
            elements.closeRoleModal.onclick = () => elements.roleModal.classList.add('hidden');
            elements.cancelRoleModal.onclick = () => elements.roleModal.classList.add('hidden');
            elements.saveRole.onclick = createRole;
            elements.aiGenerateBtn.onclick = generateRoleWithAI;
            elements.autoReplyBtn.onclick = autoReply;

            elements.chatForm.onsubmit = (e) => {
                e.preventDefault();
                sendMessage();
            };

            elements.clearChatBtn.onclick = () => {
                if (state.currentRoleId && confirm('ç¡®å®šè¦æ¸…ç©ºä¸å½“å‰è§’è‰²çš„å¯¹è¯è®°å½•å—ï¼Ÿ')) {
                    state.chatHistory[state.currentRoleId] = [];
                    saveChatHistory();
                    renderMessages();
                }
            };

            setupPlayAllButton();

            // Voice Recognition Logic
            let mediaRecorder;
            let audioChunks = [];

            elements.voiceBtn.onclick = async () => {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    elements.recordingStatus.classList.add('hidden');
                    elements.voiceBtn.classList.remove('bg-red-500', 'text-white');
                    return;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];

                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        await handleVoiceUpload(audioBlob);
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start();
                    elements.recordingStatus.classList.remove('hidden');
                    elements.voiceBtn.classList.add('bg-red-500', 'text-white');
                } catch (err) {
                    alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·ç¡®ä¿å·²æˆäºˆæƒé™ã€‚');
                    console.error(err);
                }
            };

            async function handleVoiceUpload(blob) {
                if (!state.volcAppId || !state.volcToken) {
                    alert('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½®ç«å±±å¼•æ“ AppID å’Œ Access Token');
                    return;
                }

                elements.userInput.placeholder = "æ­£åœ¨è¯†åˆ«è¯­éŸ³...";
                elements.userInput.disabled = true;

                const formData = new FormData();
                formData.append('audio', blob);
                formData.append('appid', state.volcAppId);
                formData.append('token', state.volcToken);
                formData.append('cluster', state.volcCluster);

                try {
                    const resp = await fetch('/api/asr', {
                        method: 'POST',
                        body: formData
                    });
                    const data = await resp.json();
                    if (data.text) {
                        elements.userInput.value = data.text;
                    } else {
                        alert('è¯†åˆ«å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'));
                    }
                } catch (err) {
                    console.error(err);
                    alert('è¯†åˆ«è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ' + (err.message || 'ç½‘ç»œè¿æ¥å¼‚å¸¸'));
                } finally {
                    elements.userInput.disabled = false;
                    elements.userInput.placeholder = "è¾“å…¥æ¶ˆæ¯...";
                }
            }
        }

        function saveChatHistory() {
            localStorage.setItem('chat_history', JSON.stringify(state.chatHistory));
        }

        async function fetchModels() {
            const keyToUse = elements.apiKeyInput.value || state.apiKey;
            if (!keyToUse) {
                alert('è¯·å…ˆè¾“å…¥ API Key');
                return;
            }
            elements.modelSelect.innerHTML = '<option>æ­£åœ¨è·å–æ¨¡å‹...</option>';
            try {
                const response = await fetch('https://openrouter.ai/api/v1/models', {
                    headers: { 'Authorization': `Bearer ${keyToUse}` }
                });
                const data = await response.json();
                if (data.data && Array.isArray(data.data)) {
                    state.allModels = data.data;
                    renderModelOptions(state.allModels);
                } else {
                    throw new Error('API è¿”å›æ ¼å¼é”™è¯¯');
                }
            } catch (error) {
                console.error(error);
                const fallbackModels = [
                    { id: 'x-ai/grok-4.1-fast', name: 'Grok 4.1 Fast' },
                    { id: 'x-ai/grok-2-1212', name: 'Grok 2 (1212)' },
                    { id: 'google/gemini-flash-1.5', name: 'Gemini Flash 1.5' }
                ];
                state.allModels = fallbackModels;
                renderModelOptions(fallbackModels);
                alert('è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥ API Key æ˜¯å¦æ­£ç¡®ã€‚å·²åŠ è½½å¸¸ç”¨å¤‡é€‰åˆ—è¡¨ã€‚');
            }
        }

        function renderModelOptions(models) {
            elements.modelSelect.innerHTML = '';
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = model.name || model.id;
                option.className = "py-1 px-2 hover:bg-blue-50";
                if (model.id === state.selectedModel) option.selected = true;
                elements.modelSelect.appendChild(option);
            });
            if (models.length === 0) {
                elements.modelSelect.innerHTML = '<option disabled>æœªæ‰¾åˆ°åŒ¹é…æ¨¡å‹</option>';
            }
        }

        function renderRoles() {
            elements.roleList.innerHTML = '';
            state.roles.forEach(role => {
                const isCustom = String(role.id).startsWith('custom-');
                const div = document.createElement('div');
                div.className = `role-card p-3 border border-gray-200 rounded-xl cursor-pointer hover:shadow-md transition-all flex items-center gap-3 relative group ${state.currentRoleId === role.id ? 'active' : ''}`;
                
                // Content container to separate click area from delete button
                const contentDiv = document.createElement('div');
                contentDiv.className = 'flex items-center gap-3 flex-1 overflow-hidden';
                contentDiv.onclick = () => selectRole(role.id);
                contentDiv.innerHTML = `
                    <div class="text-2xl">${role.icon || 'ğŸ‘¤'}</div>
                    <div class="flex-1 overflow-hidden">
                        <div class="font-bold text-sm truncate">${role.name}</div>
                        <div class="text-xs text-gray-500 truncate">${role.desc}</div>
                    </div>
                `;
                div.appendChild(contentDiv);

                if (isCustom) {
                    const delBtn = document.createElement('div'); // Changed from button to div to avoid potential default form submission or button behaviors
                    delBtn.className = 'absolute right-2 top-2 text-gray-400 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-all cursor-pointer z-50 p-1 bg-white rounded-full shadow-sm';
                    delBtn.innerHTML = '<i class="fas fa-times-circle text-xl"></i>';
                    delBtn.title = 'åˆ é™¤è§’è‰²';
                    
                    // Use addEventListener for more robust event handling
                    delBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Delete clicked for role:', role.id); // Debug log
                        deleteRole(role.id);
                    });
                    
                    div.appendChild(delBtn);
                }
                
                elements.roleList.appendChild(div);
            });
        }

        function deleteRole(roleId) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè§’è‰²å—ï¼Ÿç›¸å…³çš„å¯¹è¯è®°å½•ä¹Ÿå°†è¢«æ¸…é™¤ã€‚')) return;
            
            // 1. Update state first
            state.roles = state.roles.filter(r => r.id !== roleId);
            delete state.chatHistory[roleId];
            
            // 2. Persist to localStorage
            saveChatHistory();
            const customRoles = state.roles.filter(r => String(r.id).startsWith('custom-'));
            localStorage.setItem('custom_roles', JSON.stringify(customRoles));
            
            // 3. Update UI
            if (state.currentRoleId === roleId) {
                state.currentRoleId = null;
                elements.activeRoleName.textContent = 'è¯·é€‰æ‹©è§’è‰²';
                elements.activeRoleDesc.textContent = 'å¼€å§‹æ‚¨çš„å¯¹è¯';
                elements.activeRoleHeader.querySelector('div').textContent = '?';
                elements.clearChatBtn.classList.add('hidden');
                renderMessages(); // Clear messages view
            }
            
            // 4. Force re-render of role list immediately
            setTimeout(() => {
                renderRoles();
                checkInputs();
            }, 0);
        }

        async function generateRoleWithAI() {
            const userIdea = elements.aiPromptInput.value.trim();
            if (!userIdea) return alert('è¯·è¾“å…¥ä¸€ä¸ªç®€å•çš„æƒ³æ³•');
            if (!state.apiKey) return alert('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½® API Key');

            const originalBtnText = elements.aiGenerateBtn.innerHTML;
            elements.aiGenerateBtn.disabled = true;
            elements.aiGenerateBtn.innerHTML = '<i class="fas fa-spinner animate-spin"></i> ç”Ÿæˆä¸­...';

            const systemPrompt = `You are an expert RPG world builder and character designer. 
Your task is to take a simple concept and expand it into a rich, multi-dimensional role-playing scenario.
The scenario should include:
1. A compelling character name.
2. A concise but intriguing description.
3. A comprehensive System Prompt that includes:
   - Personality traits and psychological depth.
   - Detailed background and motivations.
   - Specific speech patterns, catchphrases, or linguistic quirks.
   - Guidelines on how to react to different user inputs.
   - The setting or environment they are currently in.

Return the result in JSON format with the following fields:
- name: The character's name
- desc: A short, catchy description (max 30 chars)
- prompt: The full, detailed system prompt in Chinese.
- icon: A single emoji that represents the character.

Respond ONLY with the JSON object. Do not include markdown code blocks.`;

            try {
                console.log('Generating role with model:', state.selectedModel);
                const response = await fetch('/api/proxy-llm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        apiKey: state.apiKey,
                        model: state.selectedModel,
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: `Idea: ${userIdea}` }
                        ]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Proxy Error Response:', errorData);
                    throw new Error(errorData.error?.message || errorData.message || `HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                if (data.choices && data.choices[0]) {
                    let content = data.choices[0].message.content.trim();
                    // Remove markdown code blocks if present
                    if (content.startsWith('```')) {
                        content = content.replace(/^```json\n?/, '').replace(/```$/, '').trim();
                    }
                    
                    const result = JSON.parse(content);
                    elements.newRoleName.value = result.name || '';
                    elements.newRoleDesc.value = result.desc || '';
                    elements.newRolePrompt.value = result.prompt || '';
                    elements.saveRole.dataset.generatedIcon = result.icon || 'âœ¨';
                } else if (data.error) {
                    throw new Error(data.error.message || 'API Error');
                } else {
                    throw new Error('ç”Ÿæˆå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ¨¡å‹é€‰æ‹©æˆ– API Key');
                }
            } catch (error) {
                console.error('AI Generation Error:', error);
                alert('AI ç”Ÿæˆå¤±è´¥: ' + error.message);
            } finally {
                elements.aiGenerateBtn.disabled = false;
                elements.aiGenerateBtn.innerHTML = originalBtnText;
            }
        }

        function createRole() {
            const name = elements.newRoleName.value.trim();
            const desc = elements.newRoleDesc.value.trim();
            const prompt = elements.newRolePrompt.value.trim();
            const icon = elements.saveRole.dataset.generatedIcon || 'âœ¨';
            if (!name || !prompt) return alert('è¯·å¡«å†™åç§°å’Œæç¤ºè¯');

            const newRole = {
                id: 'custom-' + Date.now(),
                name, desc, prompt, icon
            };
            state.roles.push(newRole);
            localStorage.setItem('custom_roles', JSON.stringify(state.roles.filter(r => String(r.id).startsWith('custom-'))));
            renderRoles();
            elements.roleModal.classList.add('hidden');
            // Clear inputs
            elements.newRoleName.value = '';
            elements.newRoleDesc.value = '';
            elements.newRolePrompt.value = '';
            elements.aiPromptInput.value = '';
            delete elements.saveRole.dataset.generatedIcon;
        }

        function selectRole(roleId) {
            // Stop any playing audio when switching roles
            if (state.currentAudio) {
                state.currentAudio.pause();
                state.currentAudio = null;
            }

            // Stop continuous playback if active
            if (state.isPlayingAll) {
                state.isPlayingAll = false;
            }

            state.currentRoleId = roleId;
            const role = state.roles.find(r => r.id === roleId);
            elements.activeRoleName.textContent = role.name;
            elements.activeRoleDesc.textContent = role.desc;
            elements.activeRoleHeader.querySelector('div').textContent = role.icon || 'ğŸ‘¤';
            elements.clearChatBtn.classList.remove('hidden');
            elements.playAllBtn.classList.remove('hidden');

            renderRoles();
            renderMessages();
            checkInputs();
        }

        function checkInputs() {
            const isReady = state.apiKey && state.currentRoleId;
            elements.userInput.disabled = !isReady;
            elements.sendBtn.disabled = !isReady;
            elements.voiceBtn.disabled = !state.currentRoleId;
            elements.autoReplyBtn.disabled = !isReady;
            
            if (!state.apiKey) {
                elements.userInput.placeholder = "è¯·å…ˆè®¾ç½® API Key...";
            } else if (!state.currentRoleId) {
                elements.userInput.placeholder = "è¯·é€‰æ‹©ä¸€ä¸ªè§’è‰²...";
            } else {
                elements.userInput.placeholder = "è¾“å…¥æ¶ˆæ¯...";
            }
        }

        function renderMessages() {
            elements.chatMessages.innerHTML = '';
            const messages = state.chatHistory[state.currentRoleId] || [];
            if (messages.length === 0) {
                elements.chatMessages.innerHTML = `
                    <div class="text-center text-gray-400 mt-10">
                        <p>ä¸ <b>${state.roles.find(r => r.id === state.currentRoleId).name}</b> çš„å¯¹è¯å¼€å§‹äº†</p>
                    </div>
                `;
                return;
            }

            messages.forEach((msg, index) => {
                // è·³è¿‡å·¥å…·è°ƒç”¨å’Œå·¥å…·ç»“æœæ¶ˆæ¯ï¼ˆè¿™äº›æ˜¯æŠ€æœ¯æ¶ˆæ¯ï¼Œä¸åº”è¯¥æ˜¾ç¤ºï¼‰
                if (msg.role === 'tool' || msg.tool_calls) {
                    return;
                }

                const isUser = msg.role === 'user';
                const div = document.createElement('div');
                div.className = `flex ${isUser ? 'justify-end' : 'justify-start'} items-end gap-2`;

                const contentHtml = marked.parse(msg.content);

                // Check if audio is cached for this message
                const voiceType = state.volcTtsVoice || 'zh_female_vv_uranus_bigtts';
                const cacheKey = msg.content + '_' + voiceType;
                const isCached = !isUser && state.ttsCache[cacheKey];
                const buttonClass = isCached
                    ? 'text-green-500 hover:text-green-600'
                    : 'text-gray-400 hover:text-blue-500';
                const buttonTitle = isCached ? 'æ’­æ”¾è¯­éŸ³ (å·²ç¼“å­˜)' : 'æ’­æ”¾è¯­éŸ³';

                // æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡
                const imageHtml = msg.imageUrl ? `
                    <div class="mt-3 rounded-lg overflow-hidden border border-gray-200">
                        <img src="${msg.imageUrl}"
                             alt="${msg.imagePrompt || 'ç”Ÿæˆçš„å›¾ç‰‡'}"
                             class="w-full h-auto cursor-pointer hover:opacity-90 transition-opacity"
                             onclick="window.open('${msg.imageUrl}', '_blank')"
                             loading="lazy"
                             onerror="this.onerror=null; this.parentElement.innerHTML='<div class=\\'p-4 text-center text-red-500\\'><i class=\\'fas fa-exclamation-triangle mr-2\\'></i>å›¾ç‰‡åŠ è½½å¤±è´¥<br><small>${msg.imageUrl}</small></div>';">
                        ${msg.imagePrompt ? `
                            <div class="bg-gray-50 px-3 py-2 text-xs text-gray-600 border-t border-gray-200">
                                <i class="fas fa-palette mr-1"></i>
                                æç¤ºè¯: ${msg.imagePrompt}
                            </div>
                        ` : ''}
                    </div>
                ` : '';

                div.innerHTML = `
                    <div class="max-w-[80%] rounded-2xl p-3 ${isUser ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-800 shadow-sm'} message-content relative group">
                        ${contentHtml}
                        ${imageHtml}
                        ${!isUser ? `
                            <button onclick="playTts('${msg.content.replace(/'/g, "\\'").replace(/\n/g, " ")}', this, ${index})"
                                    data-msg-index="${index}"
                                    class="absolute -right-10 bottom-0 p-2 ${buttonClass} transition-all"
                                    title="${buttonTitle}">
                                <i class="fas fa-volume-up text-lg"></i>
                            </button>
                        ` : ''}
                    </div>
                `;
                elements.chatMessages.appendChild(div);
            });
            elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
        }

        async function playTts(text, btn, index) {
            if (!state.volcAppId || !state.volcTtsToken) {
                alert('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½®ç«å±±å¼•æ“ TTS å‚æ•° (AppID å’Œ Access Token)');
                return;
            }

            // Stop continuous playback if active
            if (state.isPlayingAll) {
                stopPlayAll();
            }

            // Helper to get the current button instance (in case DOM re-rendered)
            const getButton = () => {
                const currentBtn = document.querySelector(`button[data-msg-index="${index}"]`);
                return currentBtn || btn; // Fallback to original if not found (though original might be detached)
            };

            const updateButtonState = (isLoading, isPlaying) => {
                const targetBtn = getButton();
                if (!targetBtn) return;

                const icon = targetBtn.querySelector('i');
                if (!icon) return;

                // Check if audio is cached
                const voiceType = state.volcTtsVoice || 'zh_female_vv_uranus_bigtts';
                const cacheKey = text + '_' + voiceType;
                const isCached = state.ttsCache[cacheKey];

                if (isLoading) {
                    icon.className = 'fas fa-spinner animate-spin';
                    targetBtn.disabled = true;
                    targetBtn.classList.remove('text-gray-400', 'text-green-500', 'hover:text-blue-500', 'hover:text-green-600');
                    targetBtn.classList.add('text-blue-600');
                } else if (isPlaying) {
                    icon.className = 'fas fa-volume-up';
                    targetBtn.disabled = false;
                    targetBtn.classList.remove('text-gray-400', 'text-green-500', 'hover:text-blue-500', 'hover:text-green-600');
                    targetBtn.classList.add('text-blue-600', 'animate-pulse');
                } else {
                    // Restore to idle state - green if cached, gray if not
                    icon.className = 'fas fa-volume-up';
                    targetBtn.disabled = false;
                    targetBtn.classList.remove('text-blue-600', 'animate-pulse');
                    if (isCached) {
                        targetBtn.classList.remove('text-gray-400', 'hover:text-blue-500');
                        targetBtn.classList.add('text-green-500', 'hover:text-green-600');
                        targetBtn.title = 'æ’­æ”¾è¯­éŸ³ (å·²ç¼“å­˜)';
                    } else {
                        targetBtn.classList.remove('text-green-500', 'hover:text-green-600');
                        targetBtn.classList.add('text-gray-400', 'hover:text-blue-500');
                        targetBtn.title = 'æ’­æ”¾è¯­éŸ³';
                    }
                }
            };

            // Stop previous audio if playing
            if (state.currentAudio) {
                state.currentAudio.pause();
                state.currentAudio.currentTime = 0;
                state.currentAudio = null;
                // We should ideally reset the UI of the previous button, but finding it might be complex if we didn't store it.
                // A simple global reset or just letting the new click take over is acceptable for this scope.
                // However, let's try to reset all buttons' state just in case.
                document.querySelectorAll('button[data-msg-index] i').forEach(i => {
                    i.className = 'fas fa-volume-up';
                    i.closest('button').disabled = false;
                    i.closest('button').classList.add('text-gray-400');
                    i.closest('button').classList.remove('text-blue-600', 'animate-pulse');
                });
            }

            const voiceType = state.volcTtsVoice || 'zh_female_vv_uranus_bigtts';
            const cacheKey = text + '_' + voiceType;

            const playAudio = (base64Data) => {
                const audio = new Audio("data:audio/mp3;base64," + base64Data);
                state.currentAudio = audio;
                
                updateButtonState(false, true);

                audio.onended = () => {
                    updateButtonState(false, false);
                    state.currentAudio = null;
                };

                audio.onerror = (e) => {
                    console.error('Audio Playback Error:', e);
                    alert('éŸ³é¢‘æ’­æ”¾å¤±è´¥');
                    updateButtonState(false, false);
                    state.currentAudio = null;
                };

                audio.play().catch(e => {
                    console.error('Play Promise Error:', e);
                    // Interactions requirements might block auto-play if not triggered by user, 
                    // but here it is triggered by click, so it should be fine.
                });
            };

            // Check cache first
            if (state.ttsCache[cacheKey]) {
                console.log('Using cached audio');
                playAudio(state.ttsCache[cacheKey]);
                return;
            }

            // Fetch from API
            updateButtonState(true, false);

            try {
                const response = await fetch('/api/tts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: text.substring(0, 500), // é™åˆ¶é•¿åº¦
                        appid: state.volcAppId,
                        token: state.volcTtsToken,
                        cluster: state.volcTtsCluster,
                        voice_type: voiceType
                    })
                });

                const data = await response.json();
                if (data.success && data.audio) {
                    state.ttsCache[cacheKey] = data.audio;

                    // Update button appearance to show it's cached (green color)
                    const targetBtn = getButton();
                    if (targetBtn) {
                        targetBtn.classList.remove('text-gray-400');
                        targetBtn.classList.add('text-green-500', 'hover:text-green-600');
                        targetBtn.title = 'æ’­æ”¾è¯­éŸ³ (å·²ç¼“å­˜)';
                    }

                    playAudio(data.audio);
                } else {
                    throw new Error(data.message || 'è½¬æ¢å¤±è´¥');
                }
            } catch (err) {
                console.error('TTS Error:', err);
                alert('è¯­éŸ³åˆæˆå¤±è´¥: ' + err.message);
                updateButtonState(false, false);
            }
        }

        async function playAllCachedAudio() {
            if (!state.currentRoleId) return;

            const messages = state.chatHistory[state.currentRoleId] || [];
            const voiceType = state.volcTtsVoice || 'zh_female_vv_uranus_bigtts';

            // Build queue of cached assistant messages
            state.playAllQueue = [];
            messages.forEach((msg, index) => {
                if (msg.role === 'assistant') {
                    const cacheKey = msg.content + '_' + voiceType;
                    if (state.ttsCache[cacheKey]) {
                        state.playAllQueue.push({
                            text: msg.content,
                            index: index,
                            audioData: state.ttsCache[cacheKey]
                        });
                    }
                }
            });

            if (state.playAllQueue.length === 0) {
                alert('å½“å‰åœºæ™¯æ²¡æœ‰å·²ç¼“å­˜çš„éŸ³é¢‘ã€‚è¯·å…ˆç‚¹å‡»æ¶ˆæ¯æ—çš„æ’­æ”¾æŒ‰é’®ç”ŸæˆéŸ³é¢‘ã€‚');
                return;
            }

            // Stop any currently playing audio
            if (state.currentAudio) {
                state.currentAudio.pause();
                state.currentAudio = null;
            }

            // Update button state
            const icon = elements.playAllBtn.querySelector('i');
            icon.className = 'fas fa-stop-circle text-xl';
            elements.playAllBtn.title = 'åœæ­¢è¿ç»­æ’­æ”¾';
            elements.playAllBtn.classList.remove('text-gray-400', 'hover:text-green-500');
            elements.playAllBtn.classList.add('text-red-500', 'hover:text-red-600');

            state.isPlayingAll = true;
            playNextInQueue();
        }

        function playNextInQueue() {
            if (!state.isPlayingAll || state.playAllQueue.length === 0) {
                // Playback finished or stopped
                stopPlayAll();
                return;
            }

            const item = state.playAllQueue.shift();
            const audio = new Audio("data:audio/mp3;base64," + item.audioData);
            state.currentAudio = audio;

            // Highlight the current message being played
            const btn = document.querySelector(`button[data-msg-index="${item.index}"]`);
            if (btn) {
                const icon = btn.querySelector('i');
                if (icon) {
                    icon.className = 'fas fa-volume-up';
                    btn.classList.remove('text-gray-400', 'text-green-500', 'hover:text-blue-500', 'hover:text-green-600');
                    btn.classList.add('text-blue-600', 'animate-pulse');
                }
            }

            audio.onended = () => {
                // Reset button state
                if (btn) {
                    const icon = btn.querySelector('i');
                    if (icon) {
                        icon.className = 'fas fa-volume-up';
                        btn.classList.remove('text-blue-600', 'animate-pulse');
                        btn.classList.add('text-green-500', 'hover:text-green-600');
                    }
                }
                state.currentAudio = null;

                // Play next after a short pause
                setTimeout(() => {
                    playNextInQueue();
                }, 500);
            };

            audio.onerror = (e) => {
                console.error('Audio Playback Error:', e);
                state.currentAudio = null;
                // Continue to next even if error
                playNextInQueue();
            };

            audio.play().catch(e => {
                console.error('Play Promise Error:', e);
                playNextInQueue();
            });
        }

        function stopPlayAll() {
            state.isPlayingAll = false;
            state.playAllQueue = [];

            if (state.currentAudio) {
                state.currentAudio.pause();
                state.currentAudio = null;
            }

            // Reset all button states
            document.querySelectorAll('button[data-msg-index]').forEach(btn => {
                const voiceType = state.volcTtsVoice || 'zh_female_vv_uranus_bigtts';
                const messages = state.chatHistory[state.currentRoleId] || [];
                const index = parseInt(btn.getAttribute('data-msg-index'));
                const msg = messages[index];

                if (msg) {
                    const cacheKey = msg.content + '_' + voiceType;
                    const isCached = state.ttsCache[cacheKey];

                    const icon = btn.querySelector('i');
                    if (icon) {
                        icon.className = 'fas fa-volume-up';
                        btn.classList.remove('text-blue-600', 'animate-pulse');
                        if (isCached) {
                            btn.classList.remove('text-gray-400', 'hover:text-blue-500');
                            btn.classList.add('text-green-500', 'hover:text-green-600');
                        } else {
                            btn.classList.remove('text-green-500', 'hover:text-green-600');
                            btn.classList.add('text-gray-400', 'hover:text-blue-500');
                        }
                    }
                }
            });

            // Reset play all button
            const icon = elements.playAllBtn.querySelector('i');
            icon.className = 'fas fa-play-circle text-xl';
            elements.playAllBtn.title = 'è¿ç»­æ’­æ”¾æ‰€æœ‰å·²ç¼“å­˜éŸ³é¢‘';
            elements.playAllBtn.classList.remove('text-red-500', 'hover:text-red-600');
            elements.playAllBtn.classList.add('text-gray-400', 'hover:text-green-500');
        }

        // Update playAllBtn click handler to toggle between play and stop
        function setupPlayAllButton() {
            elements.playAllBtn.onclick = () => {
                if (state.isPlayingAll) {
                    stopPlayAll();
                } else {
                    playAllCachedAudio();
                }
            };
        }

        async function autoReply() {
            if (!state.apiKey || !state.currentRoleId) return;
            
            const role = state.roles.find(r => r.id === state.currentRoleId);
            const originalPlaceholder = elements.userInput.placeholder;
            elements.userInput.placeholder = "AI æ­£åœ¨æ€è€ƒæ‚¨çš„å›å¤...";
            elements.userInput.disabled = true;
            elements.autoReplyBtn.disabled = true;

            // Prepare messages for the "User Suggestion"
            const chatHistory = state.chatHistory[state.currentRoleId] || [];
            const messages = [
                { 
                    role: 'system', 
                    content: `You are an AI assistant helping the user in a role-play with a character named "${role.name}". 
The character's profile is: ${role.prompt}

Based on the conversation history, suggest a natural, engaging response that the USER should say next. 
The response should be in Chinese, consistent with the role-play context, and move the story forward.
Respond ONLY with the suggested text, no explanations.` 
                },
                ...chatHistory.slice(-10) // Send last 10 messages for context
            ];

            try {
                const response = await fetch('/api/proxy-llm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        apiKey: state.apiKey,
                        model: state.selectedModel,
                        messages: messages
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || errorData.message || `HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                if (data.choices && data.choices[0]) {
                    elements.userInput.value = data.choices[0].message.content.trim().replace(/^["']|["']$/g, '');
                }
            } catch (error) {
                console.error('Auto Reply Error:', error);
                alert('æ— æ³•ç”Ÿæˆå»ºè®®å›å¤: ' + error.message);
            } finally {
                elements.userInput.placeholder = originalPlaceholder;
                elements.userInput.disabled = false;
                elements.autoReplyBtn.disabled = false;
                checkInputs();
            }
        }

        // å®šä¹‰æ–‡ç”Ÿå›¾å·¥å…·
        const TEXT_TO_IMAGE_TOOL = {
            type: 'function',
            function: {
                name: 'generate_image',
                description: 'æ ¹æ®æ–‡æœ¬æè¿°ç”Ÿæˆå›¾ç‰‡ã€‚å½“ç”¨æˆ·è¦æ±‚ç”Ÿæˆã€åˆ›å»ºã€ç”»å›¾ç‰‡æ—¶ä½¿ç”¨æ­¤å·¥å…·ã€‚**é‡è¦ï¼šprompt å¿…é¡»ä½¿ç”¨è‹±æ–‡æè¿°ï¼Œå¦‚æœç”¨æˆ·æä¾›ä¸­æ–‡æè¿°ï¼Œä½ éœ€è¦å…ˆå°†å…¶ç¿»è¯‘æˆè¯¦ç»†çš„è‹±æ–‡æç¤ºè¯ã€‚**',
                parameters: {
                    type: 'object',
                    properties: {
                        prompt: {
                            type: 'string',
                            description: 'å›¾ç‰‡æè¿°æ–‡æœ¬ï¼ˆå¿…é¡»ä½¿ç”¨è‹±æ–‡ï¼‰ã€‚è¯¦ç»†æè¿°æƒ³è¦ç”Ÿæˆçš„å›¾ç‰‡å†…å®¹ï¼ŒåŒ…æ‹¬ä¸»ä½“ã€é£æ ¼ã€è´¨é‡ç­‰ã€‚ä¾‹å¦‚ï¼š"A cute cat sitting on clouds, digital art style, high quality, 8k uhd"ã€‚å¦‚æœç”¨æˆ·æä¾›ä¸­æ–‡æè¿°ï¼Œè¯·å…ˆç¿»è¯‘æˆè‹±æ–‡ã€‚'
                        },
                        negative_prompt: {
                            type: 'string',
                            description: 'è´Ÿé¢æç¤ºè¯ï¼ˆè‹±æ–‡ï¼‰ï¼Œæè¿°ä¸æƒ³åœ¨å›¾ç‰‡ä¸­å‡ºç°çš„å†…å®¹',
                            default: '(deformed iris, deformed pupils, semi-realistic, cgi, 3d, render, sketch, cartoon, drawing, anime:1.4), text, close up, cropped, out of frame, worst quality, low quality, jpeg artifacts, ugly, duplicate, morbid, mutilated, extra fingers, mutated hands, poorly drawn hands, poorly drawn face, mutation, deformed, blurry, dehydrated, bad anatomy, bad proportions, extra limbs, cloned face, disfigured, gross proportions, malformed limbs, missing arms, missing legs, extra arms, extra legs, fused fingers, too many fingers, long neck'
                        },
                        width: {
                            type: 'number',
                            description: 'å›¾ç‰‡å®½åº¦ï¼ˆåƒç´ ï¼‰ï¼Œé»˜è®¤ 512',
                            default: 512,
                            enum: [512, 768, 1024]
                        },
                        height: {
                            type: 'number',
                            description: 'å›¾ç‰‡é«˜åº¦ï¼ˆåƒç´ ï¼‰ï¼Œé»˜è®¤ 728',
                            default: 728,
                            enum: [512, 728, 768, 1024]
                        }
                    },
                    required: ['prompt']
                }
            }
        };

        async function sendMessage() {
            const content = elements.userInput.value.trim();
            if (!content || !state.apiKey || !state.currentRoleId) return;

            const role = state.roles.find(r => r.id === state.currentRoleId);
            if (!state.chatHistory[state.currentRoleId]) {
                state.chatHistory[state.currentRoleId] = [];
            }

            // Add user message
            state.chatHistory[state.currentRoleId].push({ role: 'user', content });
            elements.userInput.value = '';
            renderMessages();

            // Prepare API call with Context Isolation
            let messages = [
                { role: 'system', content: role.prompt },
                ...state.chatHistory[state.currentRoleId].filter(m => m.content !== '...')
            ];

            // Add placeholder for AI response
            const aiMsg = { role: 'assistant', content: '...' };
            state.chatHistory[state.currentRoleId].push(aiMsg);
            renderMessages();

            try {
                // ç¬¬ä¸€æ¬¡è°ƒç”¨ LLMï¼Œæä¾›å·¥å…·
                let response = await fetch('/api/proxy-llm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        apiKey: state.apiKey,
                        model: state.selectedModel,
                        messages: messages,
                        tools: [TEXT_TO_IMAGE_TOOL],
                        tool_choice: 'auto',
                        replicateToken: state.replicateToken
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || errorData.message || `HTTP error! status: ${response.status}`);
                }

                let data = await response.json();

                // æ£€æŸ¥æ˜¯å¦æœ‰å·¥å…·è°ƒç”¨
                if (data.tool_results && data.tool_results.length > 0) {
                    // æœ‰å·¥å…·è°ƒç”¨ï¼Œå¤„ç†ç»“æœ
                    const toolCall = data.choices[0].message.tool_calls[0];
                    const toolResult = data.tool_results[0];
                    const resultData = JSON.parse(toolResult.content);

                    // è°ƒè¯•æ—¥å¿—
                    console.log('Tool result:', toolResult);
                    console.log('Parsed result:', resultData);
                    console.log('Image URL:', resultData.imageUrl);

                    // å°†å·¥å…·è°ƒç”¨æ·»åŠ åˆ° API æ¶ˆæ¯å†å²ï¼ˆç”¨äºåç»­è°ƒç”¨ï¼‰ï¼Œä½†ä¸æ·»åŠ åˆ° chatHistoryï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
                    messages.push(data.choices[0].message);
                    messages.push(toolResult);

                    // å¦‚æœå›¾ç‰‡ç”ŸæˆæˆåŠŸï¼Œåœ¨ AI æ¶ˆæ¯ä¸­æ˜¾ç¤ºå›¾ç‰‡
                    if (resultData.success && resultData.imageUrl) {
                        aiMsg.content = `æ­£åœ¨ç”Ÿæˆå›¾ç‰‡...`;
                        aiMsg.imageUrl = resultData.imageUrl;
                        aiMsg.imagePrompt = resultData.prompt;
                        renderMessages();

                        // ç¬¬äºŒæ¬¡è°ƒç”¨ LLMï¼Œè®©å®ƒæ ¹æ®å·¥å…·ç»“æœç”Ÿæˆå›å¤
                        response = await fetch('/api/proxy-llm', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                apiKey: state.apiKey,
                                model: state.selectedModel,
                                messages: messages
                            })
                        });

                        if (!response.ok) {
                            throw new Error('Second LLM call failed');
                        }

                        data = await response.json();
                        if (data.choices && data.choices[0]) {
                            // ç§»é™¤ LLM è¿”å›å†…å®¹ä¸­çš„ markdown å›¾ç‰‡ï¼ˆé¿å…é‡å¤æ˜¾ç¤ºï¼‰
                            let content = data.choices[0].message.content;
                            // ç§»é™¤ markdown å›¾ç‰‡è¯­æ³•: ![alt](url)
                            content = content.replace(/!\[([^\]]*)\]\([^)]+\)/g, '');
                            // ç§»é™¤å¯èƒ½çš„çº¯ URL å›¾ç‰‡é“¾æ¥
                            content = content.replace(/https?:\/\/[^\s]+\.(png|jpg|jpeg|gif|webp)[^\s]*/gi, '');
                            // æ¸…ç†å¤šä½™çš„ç©ºè¡Œ
                            content = content.replace(/\n{3,}/g, '\n\n').trim();
                            aiMsg.content = content;
                        }
                    } else if (resultData.error) {
                        aiMsg.content = `å›¾ç‰‡ç”Ÿæˆå¤±è´¥ï¼š${resultData.error}`;
                    }
                } else {
                    // æ²¡æœ‰å·¥å…·è°ƒç”¨ï¼Œæ­£å¸¸å›å¤
                    if (data.choices && data.choices[0]) {
                        aiMsg.content = data.choices[0].message.content;
                    } else {
                        aiMsg.content = "æŠ±æ­‰ï¼Œæˆ‘æ— æ³•å“åº”ã€‚è¯·æ£€æŸ¥æ‚¨çš„è®¾ç½®ã€‚";
                    }
                }
                saveChatHistory();
            } catch (error) {
                aiMsg.content = `ç½‘ç»œè¯·æ±‚å¤±è´¥: ${error.message}`;
                console.error(error);
            }
            renderMessages();
        }

        init();
    </script>
</body>
</html>
